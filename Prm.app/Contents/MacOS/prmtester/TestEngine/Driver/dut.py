from Common.BBase import *from Common.tinyrpc.dispatch import publicfrom TestEngine.Driver.TcpDriver import TcpDriverfrom Common import zmqportsfrom Log.LogClient import LogClientfrom AynsLock.LockClient import LockClientfrom ThirdParty.libDylib import *import structimport syssys.path.append("./Core")import CoreAPIclass dut(object):    """docstring for cDutModule"""    m_objShell =  cShell()    m_objBRe = cBruceRe()    def __init__(self,cfg, EngineLogPub,nSlotId,lock,objZynq= None,objNano=None,objSDev=None):        super(dut, self).__init__()        #self.nSlotId = nSlotId        self.objZynq = objZynq        self.g_lock = None        self.objEngineLogPub = EngineLogPub        self.cfg = cfg        self.strNandZero = ""        self._PDCA_KEY_MATCH_ = "{{(.+?)}}"        self._last_diags_command = ""        self._last_diags_response = ""        self.TemplatePatternTable = {}        self._SOC_P_RESPONSE = ""        self.nSlotId =nSlotId        print "Dut Id is {}".format(nSlotId)        self.strDiagsDetct = ":-)"        self.nDiagsTimeOut = 10 # s        self.objNanohippo = objNano        self.objSocketDev = objSDev        self.m_objDutLog = LogClient(self.nSlotId,"dut.log")        self.m_objTrimLog     = LogClient(self.nSlotId,"Trim.log")        self.m_objDiagsLog    = LogClient(self.nSlotId,"Diags.log")        self.m_objEFIDiagsLog =  LogClient(self.nSlotId,"EfiDiags.log")        self.m_objEfiLog = LogClient(self.nSlotId,"Efi.log")        self.m_objIEFILog =LogClient(self.nSlotId,"Iefi.log")        self.m_objRecoverLog =LogClient(self.nSlotId,"Recover.log")        self.m_objNandLog = LogClient(self.nSlotId, "Nand.log")        self.m_objiefiSendLog = LogClient(self.nSlotId, "IefiSend.log")        self.m_objI2clog = LogClient(self.nSlotId, "I2c.log")        self.m_objModeLog = LogClient(self.nSlotId, "Mode.log")        self.m_objBTime = cBruceTime()        self.bRetryFlag = 0        self.bDiagsFlags = False        self.bEnterdiagsFlag = False        self.nDutRtc = -1        self.Batt_Max = 12800.0        self.Batt_Min = 7200.0        self.bCurrentFlags = True        self.m_objGhinfo =  LibGh()        self.type_reset_table = [["07","68"],["07","68"],["07","68"],["10","68"],\                                 ["0C","6c"],["0D","68"],["00","6c"],["01","6c"],\                                 ["02","6c"],["03","6c"],["06","6c"],["08","6c"],\                                 ["0E","6c"],["0F","6c"],["11","6c"]]        self.type_eload_table = [["XAXB", "TOP", "ch1ch2", "08,6c", "00,68", "0D,6c", "07,6c"],\                                 ["XAXB", "BOT", "ch1ch2", "08,68", "00,68", "0D,6c", "07,6c"],\                                 ["TATB", "TOP", "ch3ch4", "08,6c", "00,68", "0D,6c", "07,6c"],\                                 ["TATB", "BOT", "ch3ch4", "08,68", "00,68", "0D,6c",  "07,6c"]]        self.type_swtich_table = [["2.0", "TOP", "0C,68", "0E,68", "08,6c", "01,68", "10,68", "0F,68", "0C,6c", "00,6c", "07,6c"],\                                  ["2.0", "BOT", "0C,68", "0E,68", "08,68", "02,68", "10,6c", "0F,6c", "0E,6c", "00,6c", "07,6c"],\                                  ["3.0", "TOP", "0C,68", "0E,68", "08,6c", "03,68", "10,6c", "0F,68", "00,6c", "07,6c"],\                                  ["3.0", "BOT", "0C,68", "0E,68", "08,68", "06,68", "10,6c", "0F,68", "00,6c", "07,6c"]]        self.station_id_table = {            "DFU-NAND-INIT":0x00,            "FCT":0x01,            "SOC-TEST":0x02,            "MAC1":0x03,            "ICT":0x0A,            "WIFI-BT-COND":0x15,            "WIFI-COND":0x1A,            "WIFI-BT-COND-2":0x1B        }        self.objControlCBLog = LogClient(nSlotId, "CB.log")        self.objCheckSensorLog = LogClient(nSlotId, "Check_Sensor.log")        self.objUsbLog = LogClient(nSlotId,"Usbc.log")        self.objParseLog = LogClient(nSlotId, "Parse.log")        self.objPotassiumLock = LockClient("potassium", "{}".format(nSlotId))        self.objUnloadDriverLog = LogClient(nSlotId, "UnloadDriver.log")    def Log(self):        pass    def LoopTry(slef, *args, **kwargs):        pass    def SetLogPath(self,strBaseFolder,nPort,strProjectName=""):        strAbsPath = ""        if nPort==31337:            self.objNanohippo.SetLogfile("{}/{}_iefi_31337.log".format(strBaseFolder,self.nSlotId),nPort=nPort)        elif nPort==31339:            strSmcLogPath = "{}/{}_FCT_UUT{}_{}_smc.log".format(strBaseFolder,strProjectName,self.nSlotId,self.m_objBTime.CurrentStr("%Y-%m-%d_%H-%M-%S"))            strAbsPath = strSmcLogPath            self.objUsbLog.Trace("SetLogPath port {} projectname {} RESULT:{}".format(nPort,strProjectName,strSmcLogPath))            self.objNanohippo.SetLogfile(strSmcLogPath,nPort=nPort)        return strAbsPath    @public('check_sensor')    def check_sensor(self, *args, **kwargs):        bRet = True        strRet = ""        try:            self.objCheckSensorLog.Trace("Check Sensor:{} {}".format(args,kwargs))            if len(args) >= 2:                self.diags(args[0], args[1], timeout=kwargs["timeout"], unit=kwargs["unit"])            elif len(args) == 1:                self.diags(args[0], timeout=kwargs["timeout"], unit=kwargs["unit"])            else:                bRet = False            if bRet:                strRex = "Key Read.+00000000:([\d\sa-fA-F]+)|.+"                self.objCheckSensorLog.Trace("Check Sensor Last Message:{}  Rex:{}".format(self._last_diags_command,strRex))                bRet, listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_command,strRex)                self.objCheckSensorLog.Trace("Check Sensor Match Result:{}".format(listRet))                if bRet and len(listRet) >= 1:                    strRet = listRet[0]                    bRet, strRet = self.m_objBRe.SubStr_b_str(strRet, "\s", "")                    nLen = len(strRet)                    self.objCheckSensorLog.Trace("Check Sensor Str To Value")                    if nLen == 4:                        fVault = float(int(strRet, 16)) / 256                        if fVault > 127:                            fVault = 256 - fVault                        self.objCheckSensorLog.Trace("Len4  str:{} result:{}".format(strRet,fVault))                        strRet = str(fVault)                    elif nLen == 8:                        strHex = "{}{}{}{}".format(strRet[6, 8], strRet[4, 6], strRet[2, 4], strRet[0, 2])                        floatHex = strHex.decode('hex')                        fVault = struct.unpack('!f', floatHex)[0]                        self.objCheckSensorLog.Trace("Len8  str:{} result:{}".format(strHex, fVault))                        strRet = str(fVault)                    else:                        bRet = False        except Exception as e:            bRet = False            strRet = "Exception {}".format(e)        self.objCheckSensorLog.Trace("Check Sensor:{} {} Finish".format(args, kwargs))        return strRet if bRet else "--FAIL-- {}".format(strRet)    @public("checkfailcount")    def checkfailcount(self, *args, **kwargs):        bRet = True        strRet=""        try:            strInfo=self.m_objGhinfo.GetInfo("StationType")            sd = self.station_id_table.get(strInfo.upper())            nCbMaxFailed=-1            strCbMaxFailed=self.m_objGhinfo.GetInfo("CBAuthMaxFailForStation")            try:                nCbMaxFailed = int(strCbMaxFailed)            except Exception as e:                strRet = "Exception {}".format(e)            if nCbMaxFailed >=0:                strCmd = "cbread 0x%02x" % sd                self.objNanohippo.DutSendCmd_n_str(strCmd, 3000)                strRet = self.objNanohippo.DutReadString_str()                strRex ="cbread.+0x%02X\s.+?\s(.+?)\s(.+?)\s"%sd                self.objControlCBLog.Trace("Check Rex:{}".format(strRex))                bRet3, listRet = self.m_objBRe.MatchStr_b_list(strRet, strRex)                self.objControlCBLog.Trace("Check Rex Result:{}".format(listRet))                if bRet3 and len(listRet[0]) == 2:                    strFailCount=listRet[0][1]                    nFailCount=-1                    try:                        nFailCount=int(strFailCount)                    except Exception as e:                        strRet ="Exception {}".format(e)                    if nFailCount>=0:                        if nFailCount >= nCbMaxFailed:                            bRet=False                            strRet="Relative Fail Count: {} limit:{}".format(nFailCount,nCbMaxFailed)                        else:                            bRet=True                            strRet = "{} limit:{}".format(nFailCount, nCbMaxFailed)                    else:                        bRet = False            else:                strRet="Dont check:{}".format(strCbMaxFailed)        except Exception as e:            self.objControlCBLog.Trace("Get Exception {}".format(e))            bRet = False        return "--PASS--{}".format(strRet) if bRet else "--FAIL--{}".format(strRet)    @public("checklistedcb")    def checklistedcb(self, *args, **kwargs):        bRet = True        strRet =""        try:            dictFialInfo={}            stationnames = self.m_objGhinfo.GetInfo("CBAuthStationNameToCheck")            stationids = self.m_objGhinfo.GetInfo("CBAuthNumberToCheck")            self.objControlCBLog.Trace("stationnames:{} stationids:{}".format(stationnames,stationids))            if len(stationnames)<1 or len(stationids)<1:                strRet="Network CB Check Disabled or Empty List"                self.objControlCBLog.Trace("Get Names & Ids is None ")            else:                bRet1,listNames=self.m_objBRe.SplitStr_b_list(stationnames, ";")                bRet2,listIds  =self.m_objBRe.SplitStr_b_list(stationids, ";")                if bRet1:                    listNames =filter(lambda x:x!="",listNames)                if bRet2:                    listIds = filter(lambda x:x!="", listIds)                self.objControlCBLog.Trace("Split name:{} id:{} ".format(listNames,listIds))                for i in range(0,len(listIds)):                    #strCmd = "cbread 0x%02x"%listIds[i]                    strCmd = "cbread {}".format(listIds[i])                    self.objControlCBLog.Trace("Send Cmd {}".format(strCmd))                    self.objNanohippo.DutSendCmd_n_str(strCmd, 3000)                    strRet = self.objNanohippo.DutReadString_str()                    self.objControlCBLog.Trace("Get  Rec {}".format(strRet))                    #strRex = "cbread(.+) 0x%02X \s(.+?)\s"%listIds[i]                    strRex = "0x00\s([a-zA-Z]+?)\s".format(listIds[i])                    self.objControlCBLog.Trace("Check Rex:{}".format(strRex))                    bRet3,listRet = self.m_objBRe.MatchStr_b_list(strRet,strRex)                    self.objControlCBLog.Trace("Check Rex Result:{}".format(listRet))                    if bRet3 and len(listRet)>0:                        strResult = listRet[0].upper()                        if "PASS" in strResult:                            pass                        else:                            dictFialInfo[listIds[i]]=listNames[i]+" not pass"                    else:                        bRet =False                        strRet="Match Error {}".format(listRet)                self.objControlCBLog.Trace("Check Last Fail Infos:{}".format(dictFialInfo))                if len(dictFialInfo)==0:                    bRet=True                else:                    bRet=False                    strRet=str(dictFialInfo)        except Exception as e:            self.objControlCBLog.Trace("Get Exception {}".format(e))            bRet = False        return "--PASS--" if bRet else "--FAIL--{}".format(strRet)    @public("writecb")    def writecb(self, *args, **kwargs):        bRet = True        try:            strInfo=self.m_objGhinfo.GetInfo("StationType")            #print "Get strInfo : {}".format(strInfo)            sd = self.station_id_table.get(strInfo.upper())            #print "Get Sd : {}".format(sd)            strResult=args[0]            #print "Get Args : {}".format(strResult)            nResult=0            if strResult.upper()=="TRUE":                nResult=1            try:                nResult=int(nResult)            except:                pass            self.objControlCBLog.Trace("Get nResult : {}".format(nResult))            if nResult==1:                for i in range(0,3):                    self.objControlCBLog.Trace( "{} call write  pass sd {}".format(i,sd))                    strCmd = "cbwrite 0x%02x pass\r"%sd                    self.objControlCBLog.Trace( "Start write cmd: {}".format(strCmd))                    if self.objNanohippo.WriteCB(sd, strCmd)==0:                        bRet = True                        self.objControlCBLog.Trace("write cmd Return: {}".format(bRet))                        break                    else:                        self.objControlCBLog.Trace("write cmd Start Reset Potassium Start")                        bRet =self.objNanohippo.PotassiumReset_b()                        self.m_objBTime.Delay(2000)                        if bRet:                            self.objControlCBLog.Trace("write cmd Start Reset Potassium Result {}".format(bRet))                            self.rtc("get",timeout=5000)                            self.rtc("set", timeout=5000)                        bRet = False                    self.m_objBTime.Delay(500)            else:                strCmd = "cbwrite 0x%02x fail\r"%sd                self.objControlCBLog.Trace("DutSendCmd_n_str Start {}".format(strCmd))                self.objNanohippo.DutSendCmd_n_str(strCmd,kwargs["timeout"]-2000)                self.objControlCBLog.Trace("DutReadCmd_n_str start")                strRet = self.objNanohippo.DutReadString_str()                self.objControlCBLog.Trace("Read Result {}".format(strRet))                if "OK" in strRet.upper():                    bRet = True                else:                    self.objControlCBLog.Trace("write cmd Start Reset AGAIN Potassium Start")                    bRet = self.objNanohippo.PotassiumReset_b()                    self.m_objBTime.Delay(1000)                    self.objControlCBLog.Trace("write cmd Start Reset AGAIN Potassium End")                    if bRet:                        self.objNanohippo.DutSendCmd_n_str(strCmd,kwargs["timeout"]-2000)                        strRet = self.objNanohippo.DutReadString_str()                        if "OK" in strRet.upper():                            bRet = True        except Exception as e:            strRet= "Get Exception {}".format(e)            bRet = False        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    def get_usb_module_log(self, channal, i2cSlot, deviceAddr):        self.m_objBTime.Delay(100)        self.objUsbLog.Trace("Start USB Mode Log: Channel:{} I2c:{} DeviceId:{}".format(channal,i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Send: {}".format("i2c rdwr({},{},5,1,03)".format(i2cSlot, deviceAddr)))        modeStr = self.objZynq.cmd_auto_format("i2c rdwr({},{},5,1,03)".format(i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Rece: {}".format(modeStr))        bRet, listRet = self.m_objBRe.MatchStr_b_list(modeStr, "ACK\s*\(04,(.+?);")        if bRet and len(listRet) == 1:            modeStr = listRet[0]        #self.objUsbLog.Trace("{} Mode: ".format(channal, modeStr))        self.objUsbLog.Trace("USB Mode Send: i2c rdwr({},{},7,1,34)".format(i2cSlot, deviceAddr))        PD0_Str = self.objZynq.cmd_auto_format("i2c rdwr({},{},7,1,34)".format(i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Rece: {}".format(PD0_Str))        bRet, listRet = self.m_objBRe.MatchStr_b_list(PD0_Str, "ACK\s*\(06,(.+?);")        if bRet and len(listRet) == 1:            PD0_Str = listRet[0]        self.objUsbLog.Trace("{} Mode: ".format(channal, PD0_Str))        ##        self.objUsbLog.Trace("USB Mode Send: i2c rdwr({},{},5,1,35)".format(i2cSlot, deviceAddr))        RD0_Str = self.objZynq.cmd_auto_format("i2c rdwr({},{},5,1,35)".format(i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Rece: {}".format(PD0_Str))        bRet, listRet = self.m_objBRe.MatchStr_b_list(RD0_Str, "ACK\s*\(04,(.+?);")        if bRet and len(listRet) == 1:            RD0_Str = listRet[0]        self.objUsbLog.Trace("{} Mode: ".format(channal, RD0_Str))        ##        self.objUsbLog.Trace("USB Mode Send: i2c rdwr({},{},9,1,72)".format(i2cSlot, deviceAddr))        GPIO_State_Str = self.objZynq.cmd_auto_format("i2c rdwr({},{},9,1,72)".format(i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Rece: {}".format(GPIO_State_Str))        bRet, listRet = self.m_objBRe.MatchStr_b_list(GPIO_State_Str, "ACK\s*\(40,(.+?);")        if bRet and len(listRet) == 1:            GPIO_State_Str = listRet[0]        self.objUsbLog.Trace("{} Mode: ".format(channal, GPIO_State_Str))        ##        self.objUsbLog.Trace("USB Mode Send: i2c rdwr({},{},5,1,69)".format(i2cSlot, deviceAddr))        GPIO_State_Str = self.objZynq.cmd_auto_format("i2c rdwr({},{},5,1,69)".format(i2cSlot, deviceAddr))        self.objUsbLog.Trace("USB Mode Rece: {}".format(GPIO_State_Str))        bRet, listRet = self.m_objBRe.MatchStr_b_list(GPIO_State_Str, "ACK\s*\(04,(.+?);")        if bRet and len(listRet) == 1:            GPIO_State_Str = listRet[0]        self.objUsbLog.Trace("{} Mode: ".format(channal, GPIO_State_Str))        self.objUsbLog.Trace("End USB Mode Log")    @public('usbctrl')    def usbctrl(self, *args, **kwargs):  # return b,str        channelnum = 0        i2cType = ["usbc_i2c_1", "usbc_i2c_2"]        deviceAddr = ["0x38", "0x39"]        strParam2=""        strParam1 = str(args[0])        if len(args)>=2:            strParam2 = str(args[1])        bRet = True        i2cName = ""        channeladdr = ""        try:            bRet,listRet =  self.m_objBRe.MatchStr_b_list(strParam2, "(.+?)_")            if (bRet and listRet[0] =="XA")or strParam2=="XA":                bRet = True                channelnum = 1                i2cName = i2cType[0]                channeladdr = deviceAddr[0]            elif  (bRet and listRet[0] =="XB")or strParam2=="XB":                bRet = True                channelnum = 2                i2cName = i2cType[0]                channeladdr = deviceAddr[1]            elif (bRet and listRet[0] =="TA") or strParam2=="TA":                bRet = True                channelnum = 3                i2cName = i2cType[1]                channeladdr = deviceAddr[0]            elif  (bRet and listRet[0] =="TB")or strParam2=="TB":                bRet = True                channelnum = 4                i2cName = i2cType[1]                channeladdr = deviceAddr[1]            self.objUsbLog.Trace("USB     {} : {}".format(strParam2,strParam1))            if strParam1.upper() == "RESET":                for i in range(0,len(self.type_reset_table)):                    strCmd1="i2c write({},{},3,09,01,{})".format(str(i2cName), str(channeladdr),                                                         str(self.type_reset_table[i][0]))                    strCheck1 = self.objZynq.cmd_auto_format(strCmd1)                    self.objUsbLog.Trace("Send    RESET Usb1 : {}".format(strCmd1))                    self.objUsbLog.Trace("Recieve RESET Usb1 : {}".format(strCheck1))                    strCmd2= "i2c write({},{},6,08,04,47,50,73,{})".format(str(i2cName), str(channeladdr),str(self.type_reset_table[i][1]))                    strCheck2 = self.objZynq.cmd_auto_format(strCmd2)                    self.objUsbLog.Trace("Send    RESET Usb2 : {}".format(strCmd2))                    self.objUsbLog.Trace("Recieve RESET Usb2 : {}".format(strCheck2))                    if  strCheck1.find("DONE") < 0 or strCheck2.find("DONE") < 0:                        bRet = False                        break                self.get_usb_module_log(strParam2,i2cName,channeladdr)            elif strParam1.upper() == "CONNECT":                bRet, listRet = self.m_objBRe.MatchStr_b_list(strParam2, "(.+?)_(.+?)_(.*)")                if bRet and len(listRet)==1:                    Schannel = listRet[0][0]                    Sitems   = listRet[0][1]                    Sside    = listRet[0][2]                    if Sitems == "ELOAD":                        if Schannel == "XAXB" or Schannel == "TATB":                            if Schannel == "XAXB":                                i2cName = i2cType[0]                            else:                                i2cName = i2cType[1]                            for m in range(0,len(deviceAddr)):                                for i in range(0,len(self.type_eload_table)):                                    if self.type_eload_table[i][0] == Schannel and self.type_eload_table[i][1] == Sside:                                        bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_eload_table[i][2], "ch(\d+)ch")                                        startIndex = 0                                        if bRet:                                            startIndex = int(listRet[0])                                        bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_eload_table[i][2], "ch.+?ch(\d+)")                                        endIndex = 0                                        if bRet:                                            endIndex = int(listRet[0])                                        for j in range(startIndex-1,endIndex):                                            for k in range(3,len(self.type_eload_table[i])):                                                bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_eload_table[i][k],"(.+),")                                                if bRet:                                                    strCmd1="i2c write({},{},3,09,01,{})".format(i2cName,deviceAddr[m],listRet[0])                                                    strCheck1 = self.objZynq.cmd_auto_format(strCmd1)                                                    self.objUsbLog.Trace("Send    CONNECT ELOAD Usb1 : {}".format(strCmd1))                                                    self.objUsbLog.Trace("Recieve CONNECT ELOAD Usb1 : {}".format(strCheck1))                                                bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_eload_table[i][k], ",(.+)")                                                if bRet:                                                    strCmd2 = "i2c write({},{},6,08,04,47,50,73,{})".format(i2cName, deviceAddr[m],listRet[0])                                                    strCheck2 = self.objZynq.cmd_auto_format(strCmd2)                                                    self.objUsbLog.Trace("Send    CONNECT ELOAD Usb2 : {}".format(strCmd2))                                                    self.objUsbLog.Trace("Recieve CONNECT ELOAD Usb2 : {}".format(strCheck2))                                                    if strCheck1.find("DONE")<0 or strCheck2.find("DONE")<0:                                                        bRet = False                                                        break                                            if bRet== False:                                                break                                    if bRet == False:                                        break                                self.get_usb_module_log(strParam2, i2cName, deviceAddr[m])                                if bRet == False:                                    break                    else:                        self.objSocketDev.DutReadString_str()                        self.objSocketDev.DutSetDetectString("0")                        for i in range(0, len(self.type_swtich_table)):                            self.objUsbLog.Trace("Check Sitems:{} Sside:{}".format(Sitems,Sside))                            if self.type_swtich_table[i][0] == Sitems and self.type_swtich_table[i][1] == Sside:                                for j in range(2,len(self.type_swtich_table[i])):                                    bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_swtich_table[i][j], "(.+),")                                    if bRet:                                        strCmd1="i2c write({},{},3,09,01,{})".format(i2cName, channeladdr,listRet[0])                                        strCheck1 = self.objZynq.cmd_auto_format(strCmd1)                                        self.objUsbLog.Trace("Send    CONNECT ELSE Usb1 : {}".format(strCmd1))                                        self.objUsbLog.Trace("Recieve CONNECT ELSE Usb1 : {}".format(strCheck1))                                    bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_swtich_table[i][j],",(.+)")                                    if bRet:                                        strCmd2="i2c write({},{},6,08,04,47,50,73,{})".format(i2cName, channeladdr,listRet[0])                                        strCheck2 = self.objZynq.cmd_auto_format(strCmd2)                                        self.objUsbLog.Trace("Send    CONNECT ELSE Usb2 : {}".format(strCmd2))                                        self.objUsbLog.Trace("Recieve CONNECT ELSE Usb2 : {}".format(strCheck2))                                        if strCheck1.find("DONE") < 0 or strCheck2.find("DONE")< 0:                                            bRet = False                                            break                                if bRet == False:                                    break                        if bRet==True:                            nRet =self.objSocketDev.DutWaitForString_n(3000)                            #print("Readback during USB plug in: "..self.objSocketDev.DutReadString_str())                            if nRet!=0:                                for i in range(0,len(self.type_reset_table)):                                    strCmd1="i2c write({},{},3,09,01,{})".format(i2cName, channeladdr, self.type_reset_table[i][0])                                    strCheck1 = self.objZynq.cmd_auto_format(strCmd1)                                    self.objUsbLog.Trace("Send    CONNECT ELSE RETRY Usb1 : {}".format(strCmd1))                                    self.objUsbLog.Trace("Recieve CONNECT ELSE RETRY Usb1 : {}".format(strCheck1))                                    strCmd2 = "i2c write({},{},6,08,04,47,50,73,{})".format(i2cName, channeladdr,self.type_reset_table[i][1])                                    strCheck2 = self.objZynq.cmd_auto_format(strCmd2)                                    self.objUsbLog.Trace("Send     CONNECT ELSE RETRY Usb2 : {}".format(strCmd2))                                    self.objUsbLog.Trace("Recieve  CONNECT ELSE RETRY Usb2 : {}".format(strCheck2))                                    if strCheck1.find("DONE") < 0 or strCheck2.find("DONE") < 0:                                        bRet = False                                        print "ReTry Fail !!"                                        break                                if bRet:                                    self.m_objBTime.Delay(1000)                                    for i in range(0, len(self.type_swtich_table)):                                        if self.type_swtich_table[i][0] == Sitems and self.type_swtich_table[i][1] == Sside:                                            for j in range(2, len(self.type_swtich_table[i])):                                                bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_swtich_table[i][j], "(.+),")                                                if bRet:                                                    strCmd1="i2c write({},{},3,09,01,{})".format(i2cName, channeladdr,listRet[0])                                                    strCheck1 = self.objZynq.cmd_auto_format(strCmd1)                                                    self.objUsbLog.Trace("Send    CONNECT ELSE RETRY TRUE Usb1 : {}".format(strCmd1))                                                    self.objUsbLog.Trace("Recieve CONNECT ELSE RETRY TRUE Usb1 : {}".format(strCheck1))                                                bRet, listRet = self.m_objBRe.MatchStr_b_list(self.type_swtich_table[i][j], ",(.+)")                                                if bRet:                                                    strCmd2 = "i2c write({},{},6,08,04,47,50,73,{})".format(i2cName,channeladdr,listRet[0])                                                    strCheck2 = self.objZynq.cmd_auto_format(strCmd2)                                                    self.objUsbLog.Trace("Send    CONNECT ELSE RETRY TRUE Usb2 : {}".format(strCmd2))                                                    self.objUsbLog.Trace("Recieve CONNECT ELSE RETRY TRUE Usb2 : {}".format(strCheck2))                                                    if  strCheck1.find("DONE") < 0 or strCheck2.find("DONE") < 0:                                                        bRet = False                                                        break                                    self.objSocketDev.DutReadString_str()                            self.get_usb_module_log(strParam2, i2cName, channeladdr)                else:                    bRet = False            else:                bRet = False        except Exception as e:            bRet = False        return "--PASS--" if bRet else "--FAIL--"    @public("timerreset")    def timerreset(self, *args, **kwargs):        self.m_objBTime.Start()        return "--PASS--"    @public("timerstop")    def timerstop(self, *args, **kwargs):        endtime = round(self.m_objBTime.Stop_n()/1000,3)        return str(endtime)    @public('usbfs')    def usbfs(self, *args, **kwargs):# return b,str        bRet = True        strRet = ""        try:            strPath = args[0]            strLogPath = "/tmp/usbfs_{}.txt".format(self.nSlotId)            strCmd = "ps -ef | grep -v grep | grep {} -n {}".format(strPath,self.nSlotId+1)            bRet = True            strRet = "****usbfs is already Running*******"            if self.m_objShell.RunShell_n(strCmd) !=0:                strCmd = "/usr/local/bin/usbfs -f {} -n  {} > {} &".format(strPath,self.nSlotId+1,strLogPath)                bRet=False                if self.m_objShell.RunShell_n(strCmd)!=0:                    bRet =False                    strRet = "****usbfs start fail!!!*******"                else:                    bRet = True                    strRet = "****usbfs is start Running*******"        except:            bRet = False        return "--PASS--" if bRet else "--FAIL--"    @public('diags')    def diags(self, *args, **kwargs):        bRet = True        strRet = ""        try:            self._SOC_P_RESPONSE = ""            nDiagsTimeout = 25000            bRet,listRet = self.m_objBRe.SplitStr_b_list(str(args[0]),"\*")            param0 =args[0]            if bRet:                param0 = listRet[0]                if len(listRet)>=2:                    nDiagsTimeout = listRet[1]            strCommand = param0            strDiagsDet = ""            if len(args)>=2:                strDiagsDet = args[1]            else:                strDiagsDet = ":-)"            self.objNanohippo.DutSetDetectString(strDiagsDet)            self.m_objBTime.Delay(10)            if len(re.findall(str(param0), "usbfs -e")) > 0:                strCommand = "usbfs -e -n {}".format(str(self.nSlotId + 1))            if len(re.findall(str(param0), "usbfs -d")) > 0:                strCommand = "usbfs -d -n {}".format(str(self.nSlotId + 1))            if len(re.findall(str(param0), "--mount")) > 0:                strCommand = "usbfs -m -n {}".format(str(self.nSlotId + 1))            self._last_diags_command = strCommand            self.m_objBTime.Delay(10)            self.objNanohippo.DutReadString_str()            self.m_objBTime.Delay(50)            self.m_objDiagsLog.Trace("Diags Start:{} {}".format(strDiagsDet,nDiagsTimeout))            bRet = True            strRet = ""            ##            if strCommand != "":                self.m_objDiagsLog.Trace("Send Diags Cmd:{}".format(strCommand))                nRet, strRet = self.objNanohippo.DutSendCmd_n_str(strCommand, nDiagsTimeout)                self.m_objBTime.Delay(50)                if nRet != 0:                    self.m_objDiagsLog.Trace("PotassiumReset Call")                    self.objNanohippo.PotassiumReset_b()                    self.m_objBTime.Delay(1000)                    nRet, strRet = self.objNanohippo.DutSendCmd_n_str(strCommand, nDiagsTimeout)                if nRet != 0:                    self._last_diags_response = self.objNanohippo.DutReadString_str()                    self.objNanohippo.DutSendString_n("consolerouter -t")                    self.m_objBTime.Delay(10000)                    self.objNanohippo.DutSendString_n("smc dump")                    self.m_objBTime.Delay(5000)                    bRet = False                    strRet = "--FAIL--diags nTimeOut NO_RETURN"                else:                    self._last_diags_response = self.objNanohippo.DutReadString_str()                    self.m_objBTime.Delay(50)                self.m_objDiagsLog.Trace("Rece Diags nRet:{} Str:{} Detect:{}".format(nRet,self._last_diags_response,self.objNanohippo.DutGetDetectString()))            else:                bRet = False                strRet = "ERROCODE[-6]Problem with diags strCommand string or variable substitution: {}".format(strCommand)            self.bDiagsFlags = bRet        except Exception as e:            bRet = False            strRet = "Except {}".format(e)        self.m_objDiagsLog.Trace("Diags End:{}".format(bRet))        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    @public('detect')           def detect(self, *args, **kwargs):        bRet = True        strRet = ""        try:                        strDetect = args[0]                        nTimeOut = 30000                        print kwargs["timeout"]            if kwargs["timeout"] !='':                nTimeOut = int(kwargs["timeout"])            self.objNanohippo.DutSetDetectString(strDetect)            nRet, strData = self.objNanohippo.DutWaitForString_n_str(nTimeOut)            bRet = True            strRet = ""            if nRet !=0:                if self.m_objBRe.MatchStr_b(":-\)", strDetect):                    bRet = False                    strRet = "TimeOut"                else:                    bRet = False                    strRet = "Timeout wait {}".format(strDetect)            if bRet:                strRet = self.objNanohippo.DutReadString_str()                bRet1,listRet=self.m_objBRe.MatchStr_b_list("(.+?)[\r\n]+",strData)                if bRet and bRet1 and nRet==1 and ":-)" in listRet[0]:                    nRet, strData = self.objNanohippo.DutWaitForString_n_str(nTimeOut)                    if nRet != 0:                        bRet = False                        strRet = "--FAIL--diags nTimeOut"                        if args[0] == "starting strCommand prompt":                            pass                        else:                            self.objNanohippo.DutSetDetectString(":-\)")        except Exception as e:            bRet = False            strRet = "Except {}".format(e)        return "--PASS--" if bRet else strRet    @public('parse')    def parse(self, *args, **kwargs):        bRet = True        strRet = ""        try:            self.objParseLog.Trace("Start Parse")            strFilePath = "./MessageFormat/{}.txt".format(self._last_diags_command)            strKeyName = args[0]            self.objParseLog.Trace("Match Key:<{}> In FormatFileName:<{}>".format(strKeyName, strFilePath))            self.objParseLog.Trace("MessageStartNextLine:**********\n{}\nMessageEnd:***********".format(self._last_diags_response))            bRet = True            strRet = ""            if self.bDiagsFlags:                bRet, strRet ,strMacthRex,strFormat =CoreAPI.PraseForFile(strFilePath, strKeyName,self._last_diags_response) #self.m_objBRe.PraseForFile3(strFilePath, strKeyName,self._last_diags_response)                self.objParseLog.Trace("Match Rex:{}\nFormatFormat:{}\n".format(strMacthRex, strFormat))                if bRet:                    bRet,strRet = self.m_objBRe.SubStr_b_str(strRet,"\r","")                self.objParseLog.Trace("Match Result:{}".format(strRet))            else:                bRet = False        except:            bRet = False            strRet = "Except"        self.objParseLog.Trace("End Parse")        return strRet if bRet else "--FAIL-- {}".format(strRet)    @public('potassium')    def potassium(self, *args, **kwargs):        bRet = True        strRet = ""        try:            if int(args[0])==1:                self.objPotassiumLock.Lock(True)                bRet = self.objNanohippo.Connect_b()                self.objPotassiumLock.Lock(False)                self.m_objBTime.Delay(50)                if not bRet:                    bRet= self.objNanohippo.PotassiumReset_b()            elif int(args[0])==0:                self.objNanohippo.Close()                bRet= True        except:            srtRet = "Except"            bRet = False        strRet =  "--PASS--" if bRet else "--FAIL-- {}".format(strRet)        return strRet                @public('potassiumreset')    def potassiumreset(self, *args, **kwargs):        bRet = self.objNanohippo.PotassiumReset_b()        self.m_objBTime.Delay(1000)         return "--PASS--" if bRet else "--FAIL--"    def GetCurrentMode(self):        bRet = False        try:            strMode= ""            self.m_objModeLog.Trace("Check Recover Mode Start")            for i in range(0,3):                self.objNanohippo.DutSendString_n("checkbootstatus")                self.m_objBTime.Delay(500)                strDutstatusRespond = self.objNanohippo.DutReadString_str()                self.m_objModeLog.Trace("checkbootstatus Ret:{}".format(strDutstatusRespond))                                if ":-)" in strDutstatusRespond:                    strMode = "iefi"                    self.m_objModeLog.Trace("Mode Find :-) : {}".format(strMode))                    bRet = True                    break                if "]" in strDutstatusRespond:                    strMode = "recover"                    self.m_objModeLog.Trace("Mode Find ] : {}".format(strMode))                    bRet = True                    break                # if ":\\>" in strDutstatusRespond:                #     strMode = "efi"                #     self.m_objModeLog.Trace("Mode Find :\> {}".format(strMode))                #     bRet = True                #     break        except Exception as e:            self.m_objModeLog.Trace("Check Recover Mode Exception {}".format(e))            bRet = False        self.m_objModeLog.Trace("Current Mode:{}".format(strMode))        return bRet,strMode    @public('enteriboot')    def enteriboot(self, *args, **kwargs):        bRet = True        strRet = ""        try:            nTestCount = 0            nEnterBootTimeout =kwargs["timeout"] - 25000            self.m_objRecoverLog.Trace("Enter Iboot Start:timeout {}".format(nEnterBootTimeout))            self.objNanohippo.ClearBuffer(31337)            nBeginTimestamp = self.m_objBTime.Current()            nEndTimestamp = 0            bRet = False            strRet = ""            #self.m_objBTime.Delay(6000)            while nEndTimestamp - nBeginTimestamp < nEnterBootTimeout:                strDutstatusRespond = self.objNanohippo.DutReadString_str()                self.m_objRecoverLog.Trace("Enter Recover Loop Read:{}".format(strDutstatusRespond))                if self.m_objBRe.MatchStr_b(strDutstatusRespond, "SYNTAX"):                    self.m_objRecoverLog.Trace("Find : SYNTAX  End Loop")                    self.bEnterdiagsFlag = True                    bRet = True                    break                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "][\s]*$"):                    self.m_objRecoverLog.Trace("Find : ]")                    self.m_objBTime.Delay(500)                    self.m_objRecoverLog.Trace("Send :checkbootstatus")                    self.objNanohippo.DutSendString_n("checkbootstatus")                    self.m_objBTime.Delay(500)                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "~ root#"):                    self.m_objRecoverLog.Trace("Send :reboot")                    self.objNanohippo.DutSendString_n("reboot")                    self.m_objBTime.Delay(6000)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                    self.m_objBTime.Delay(3000)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                    self.m_objBTime.Delay(1500)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "Password"):                    self.m_objRecoverLog.Trace("Find :Password")                    self.m_objRecoverLog.Trace("Send :alpine")                    self.objNanohippo.DutSendString_n("alpine")                    self.m_objBTime.Delay(100)                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "login"):                    self.m_objRecoverLog.Trace("Find Login")                    self.m_objRecoverLog.Trace("Send :root")                    self.objNanohippo.DutSendString_n("root")                    self.m_objBTime.Delay(100)                else:                    self.m_objRecoverLog.Trace("Enter Recover Else")                    self.objNanohippo.DutSendString_n("ENTER")                    self.m_objBTime.Delay(500)                bRet=False                if nTestCount >= 30:                    self.m_objRecoverLog.Trace("Enter Recover  Time Out RetSet Potassium Loop End")                    #self.g_lock.Lock(True)                    self.objNanohippo.PotassiumReset_b()                    #self.m_objBTime.Delay(1000)                    #self.g_lock.Lock(False)                    bRet=False                    nTestCount = 0                    #break                nTestCount += 1                nEndTimestamp = self.m_objBTime.Current()        except:            bRet = False            strRet = "Except"        self.m_objRecoverLog.Trace("Enter Recover End :{}".format(bRet))        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    @public('fsboot')    def fsboot(self, *args, **kwargs):        bRet = True        strRet = ""        try:            nTestCount = 0            strDutsendcmd = "\r\n"            nEnterBootTimeout =kwargs["timeout"] - 5000            self.m_objRecoverLog.Trace("Enter Iboot Start:timeout {}".format(nEnterBootTimeout))            self.objNanohippo.ClearBuffer(31337)            nBeginTimestamp = self.m_objBTime.Current()            nEndTimestamp = 0            bRet = False            strRet = ""            self.m_objRecoverLog.Trace("Enter Send Str:{}".format("fsboot"))            self.objNanohippo.DutSendString_n("fsboot")            self.m_objBTime.Delay(6000)            self.m_objRecoverLog.Trace("Enter Send Str:{}".format(strDutsendcmd))            self.objNanohippo.DutSendString_n(strDutsendcmd)            while nEndTimestamp - nBeginTimestamp < nEnterBootTimeout:                strDutstatusRespond = self.objNanohippo.DutReadString_str()                self.m_objRecoverLog.Trace("Enter Recover Loop Read:{}".format(strDutstatusRespond))                if strDutstatusRespond=="":                    pass                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, ":-\)"):                    self.m_objRecoverLog.Trace("Find : :\)  End Loop")                    bRet = True                    break                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "SYNTAX"):                    self.m_objRecoverLog.Trace("Find : SYNTAX  End Loop")                    self.bEnterdiagsFlag = True                    bRet = True                    break                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "login:"):                    self.m_objRecoverLog.Trace("Find Login")                    self.m_objRecoverLog.Trace("Send :root")                    self.objNanohippo.DutSendString_n("root")                    self.m_objBTime.Delay(100)                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "Password"):                    self.m_objRecoverLog.Trace("Find :Password")                    self.m_objRecoverLog.Trace("Send :alpine")                    self.objNanohippo.DutSendString_n("alpine")                    self.m_objBTime.Delay(100)                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "~ root#"):                    self.m_objRecoverLog.Trace("Send :reboot")                    self.objNanohippo.DutSendString_n("reboot")                    self.m_objBTime.Delay(6000)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                    self.m_objBTime.Delay(3000)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                    self.m_objBTime.Delay(1500)                    self.m_objRecoverLog.Trace("Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                elif self.m_objBRe.MatchStr_b(strDutstatusRespond, "][\s\S]*$"):                    self.m_objRecoverLog.Trace("Find : ]")                    self.m_objBTime.Delay(500)                    self.m_objRecoverLog.Trace("Send :checkbootstatus")                    self.objNanohippo.DutSendString_n("checkbootstatus")                    self.m_objBTime.Delay(500)                else:                    self.m_objRecoverLog.Trace("Enter Recover Send :ENTER")                    self.objNanohippo.DutSendString_n("ENTER")                bRet=False                if nTestCount >= 50:                    self.m_objRecoverLog.Trace("Enter Recover  Time Out RetSet Potassium Loop End")                    #self.g_lock.Lock(True)                    self.objNanohippo.PotassiumReset_b()                    self.m_objBTime.Delay(1000)                    #self.g_lock.Lock(False)                    bRet=False                    break                nTestCount += 1                nEndTimestamp = self.m_objBTime.Current()               except:            bRet = False            strRet = "Except"        self.m_objRecoverLog.Trace("Enter Recover End :{}".format(bRet))        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    @public('parse_i2c_device')    def parse_i2c_device(self, *args, **kwargs):        bRet = False        strRet = ""        listMatchFlag = [False, False, False]        listMatchRex = ["\(7-bit\) 0xD \(8-bit\) 0x1A", "\(7-bit\) 0x22 \(8-bit\) 0x44",                        "\(7-bit\) 0x4A \(8-bit\) 0x94"]        if self.bDiagsFlags:            for i in range(0,len(listMatchFlag)):                listMatchFlag[i] = self.m_objBRe.MatchStr_b(self._last_diags_response,listMatchRex[i])            if False in listMatchFlag:                bRet = False            else:                bRet = True        self.m_objI2clog.Trace("Parse I2c Check Result : {}".format(dict(zip(listMatchRex,listMatchFlag))))        return "--PASS--" if bRet else "--FAIL--"    @public('parseI2C')    def parseI2C(self, *args, **kwargs):        bRet = False        strRet = ""        if self.bDiagsFlags:            bRet = self.m_objBRe.MatchStr_b(self._last_diags_response,".+, buffer read:(.+)0x\dC.+")            return strRet if bRet else "--FAIL--"    @public('iefiparse')    def iefiparse(self, *args, **kwargs):        bRet = False        strRet = ""        if self.bDiagsFlags:            bRet,listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,"Exception(.+)occurred")            print "iefiparse : response:{} VS rex:{}".format(self._last_diags_response,args[0])            if bRet==False or len(listRet)==0:                bRet,listRet= self.m_objBRe.MatchStr_b_list(self._last_diags_response,args[0])                print "iefiparse : response:{} VS rex:{}".format(self._last_diags_response, args[0])                if bRet and len(listRet):                    bRet , strRet = self.m_objBRe.SubStr_b_str(listRet[0],"[\r\n]","")            else:                bRet=False                strRet = "Find Exception  in iefiparse"        return strRet if bRet else "--FAIL--"    @public('parsedmic')    def parsedmic(self, *args, **kwargs):        bRet = False        strRet = ""        try:            bRet,listKey = self.m_objBRe.MatchStr_b_list(args[0],self._PDCA_KEY_MATCH_)            strKey = listKey[0]            if self.bDiagsFlags:                strRex = "[\s\S]+Channel 2:[\s\S]+Magnitude=(.+?)FS[\s\S]+Frequency:(.+?)/-[\s\S]+SINAD=(.+?)dBFS[\s\S]+T.+?N:(.+?)dB[\s\S]+"                bRet, listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,strRex)                if len(listRet[0]) == 4:                    dictRet = {}                    dictRet["fft_peak_magnitude2"] = listRet[0][0]                    dictRet["fft_peak_frequency2"] = listRet[0][1]                    dictRet["sinad2"] = listRet[0][2]                    dictRet["thdn2"] = listRet[0][3]                    if strKey in dictRet.keys():                        bRet,strRet = self.m_objBRe.SubStr_b_str(dictRet[strKey], " ", "")        except:            bRet = False            strRet = "EXCEPT"        return strRet if bRet else "--FAIL-- {}".format(strRet)    @public('smokey')    def smokey(self, *args, **kwargs):        strCmd = args[0]        strCmd = "smokeyshell -f nandfs:\\AppleInternal\\Diags\\Scripts\\X527\\{}".format(strCmd)        bRet,strRet = self.diags(args[0],args[1],timeout=kwargs["timeout"],unit=kwargs["unit"])        bRet,listRet =  self.m_objBRe.MatchStr_b_list(strCmd,"(.+?) ") #string.match(tostring(strCmd),"(.+?) ")        if bRet:            self._last_diags_command = listRet[0]            print "_last_diags_command -->> {}".format(self._last_diags_command)        return strRet if bRet else "--FAIL--"    @public('iefidiags')    def iefidiags(self, *args, **kwargs):        bRet = True        strRet = ""        nTimeOut = kwargs["timeout"]        if self.m_objBRe.MatchStr_b(args[1],"\%"):            #value = string_match(self._SOC_P_RESPONSE,args[1])            nRet,listRet = self.m_objBRe.MatchStr_b_list(self._SOC_P_RESPONSE,args[0])            if nRet:                self.objNanohippo.DutReadString_str()                nRet,strRet = self.objNanohippo.DutSendCmd_n_str(self._last_diags_command, ((nTimeOut/2)-300))                self._SOC_P_RESPONSE = self.objNanohippo.DutReadString_str()                nRet,listRet = self.m_objBRe.MatchStr_b_list(self._SOC_P_RESPONSE,args[0])                if nRet:                    strRet = listRet[0]        else:            self._SOC_P_RESPONSE = ""            self._last_diags_command = args[0]            self.objNanohippo.DutReadString_str()            for i in range(0,3):                nRet,strRet = self.objNanohippo.DutSendCmd_n_str(self._last_diags_command, ((nTimeOut)/2-300))                self._SOC_P_RESPONSE = self.objNanohippo.DutReadString_str()                if nRet == 0:                    bRet = True                    break            if bRet==False:                strRet = "--FAIL--diags timeout"        if bRet:            bRet,strRet=self.m_objBRe.SubStr_b_str(strRet,"[\r\n]","")        return strRet if bRet else "--FAIL--"    @public('iefisend')    def iefisend(self, *args, **kwargs):        bRet = True        strRet = ""        nTimeOut = kwargs["timeout"]        strCommand = ""        try:            self.m_objiefiSendLog.Trace("IefiSend Start {}".format(args))            strCommand = args[0]            strDetect = ""            if len(args)>=2:                strDetect = args[1]                nTimeOut-=2000                self.objNanohippo.DutReadString_str()                self.m_objiefiSendLog.Trace("IefiSend Send String {}".format(strCommand))                nRet = self.objNanohippo.DutSendString_n(strCommand)                if nRet != 0:                    bRet = False                    strRet = "ERROCODE[-6]Problem with diags command string or variable substitution: {}".format(strCommand)                else:                    self.m_objiefiSendLog.Trace("IefiSend WaitStr {} {}".format(strDetect,nTimeOut))                    nRet = self.objNanohippo.DutWaitStr_n(strDetect, nTimeOut)                if nRet != 0:                    self.m_objiefiSendLog.Trace("PotassiumReset Call")                    self.objNanohippo.PotassiumReset_b()                    self.m_objBTime.Delay(1000)                    nRet = self.objNanohippo.DutSendString_n(strCommand)                    if nRet != 0:                        bRet = False                        strRet = "ERROCODE[-6]Problem with diags command string or variable substitution: {}".format(strCommand)                    else:                        nRet = self.objNanohippo.DutWaitStr_n(strDetect, nTimeOut)                if nRet != 0:                    self.objNanohippo.DutReadString_str()                    self.objNanohippo.DutSendString_n("consolerouter -t")                    self.m_objBTime.Delay(10000)                    self.objNanohippo.DutSendString_n("smc dump")                    self.m_objBTime.Delay(5000)                    bRet = False                    strRet = "--FAIL--iefiSend nTimeOut NO_RETURN"            else:                if self.m_objBRe.MatchStr_b(strCommand,"reset"):                    self.bEnterdiagsFlag = True                self.objNanohippo.DutReadString_str()                nRet = self.objNanohippo.DutSendString_n(strCommand)                if nRet !=0:                    bRet = False                    strRet = "ERROCODE[-6]Problem with diags command string or variable substitution: {}".format(strCommand)            except Exception as e:            bRet = False            strRet = "strCommand Exception"        self.m_objiefiSendLog.Trace("IefiSend Finish {} {}".format(bRet, strRet))        return "--PASS--" if bRet else "--FAIL--"    @public('rtc')    def rtc(self, *args, **kwargs):        bRet = True        strRet = ""        nTimeOut = kwargs["timeout"]-2000        strCommand = ""        try:            strCommand = args[0]            if bRet:                if self.m_objBRe.MatchStr_b(strCommand,"get"):                    nRet,strRet=  self.objNanohippo.DutSendCmd_n_str("rtc --get",nTimeOut)                    if nRet==0:                        strRet = self.objNanohippo.DutReadString_str(nTimeOut)                        nCurrentTime = self.m_objBTime.Current()                        strRex = "RTC_Time: (\d+?)\.(\d+?)\.(\d+?)\.(\d+?)\.(\d+?)\.(\d+?)"                        bRet,listRet = self.m_objBRe.MatchStr_b_list(strRet,strRex)                        if bRet and len(listRet)==1:                            strRet = "{}-{}-{} {}:{}:{}".\                                format(listRet[0][0],listRet[0][1],listRet[0][2],listRet[0][3],listRet[0][4],listRet[0][5])                            nRtc = self.m_objBTime.StrToTemp(strRet,'%Y-%m-%d %H:%M:%S')                            if nCurrentTime - nRtc >1800:                                self.nDutRtc = nCurrentTime                            else:                                self.nDutRtc =1 #??                        else:                            self.nDutRtc = -9999                    else:                        bRet = False                elif self.m_objBRe.MatchStr_b(strCommand,"set"):                    if self.nDutRtc == -9999 or self.nDutRtc == -1:                        bRet =False                        strRet = "--FAIL--fail to get time"                    elif self.nDutRtc == 1:                        strRet = "--PASS--Dont not set time"                    else:                        strTemp = self.m_objBTime.TempToStr(self.m_objBTime.Current()/1000,'%Y%m%d%H%M%S')                        nRet,strRet= self.objNanohippo.DutSendCmd_n_str("rtc --set {}".format(strTemp),nTimeOut)                        if nRet ==0:                            strRet = self.objNanohippo.DutReadString_str()                            if self.m_objBRe.MatchStr_b(strRet,"\d+") != True:                                bRet = False                                strRet ="--FAIL--fail to set rtc"                        else:                            bRet = False                            strRet ="--FAIL--fail to set rtc"                else:                    bRet = False                    strRet ="--FAIL--Unknow Rct Cmd"        except Exception as e:            bRet = False            strRet = "Get Exception {}".format(e)        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)        #efi functions    @public('unload_driver')    def unload_driver(self, *args, **kwargs):        xRet = ""        bRet = False        strRet = ""        strDirverName = ""        try:            strDirverName = args[0].lower()            nTimeout = int(kwargs["timeout"] - 3000)            self.efidiags("drivers", timeout=kwargs["timeout"] - 1000)            self.objUnloadDriverLog.Trace("unload_deiver Start:{} {}".format(args,kwargs))            strFormat = "{{none}}\n{{driverid}}" + "{}".format(strDirverName) + "{{none}}" #"broadcom 802.11 dongle host driver"            self._last_diags_response = self._last_diags_response.lower()            self.objUnloadDriverLog.Trace("unload_deiver Format:{}".format(strFormat))            self.objUnloadDriverLog.Trace("unload_deiver LastResponse:{}".format(self._last_diags_response))            bRet, strRet, strMacthRex, strFormat = CoreAPI.PraseForFormat(strFormat, "{{driverid}}", self._last_diags_response)            self.objUnloadDriverLog.Trace("unload_deiver Match Result:{} {} {} {}".format(bRet, strRet, strMacthRex, strFormat))            if bRet:                bRet, strRet  = CoreAPI.SubStr_b_str(strRet, "\[*[0-9]+m", "")                bRet, listRet = CoreAPI.SplitStr_b_list(strRet," ")                if bRet and len(listRet) > 0:                    strDriverId = listRet[0]                    self.objUnloadDriverLog.Trace("unload_deiver Catch Id:{}".format(strDriverId))                    strUnloadCmd = "unload {} -n".format(strDriverId)                    self.objUnloadDriverLog.Trace("unload_deiver Auto Cmd:{}".format(strUnloadCmd))                    xRet = self.efidiags(strUnloadCmd,timeout=kwargs["timeout"]-1000)                    bRet = True                else:                    bRet = False        except Exception as e:            bRet = False            strRet = "Except {}".format(str(e))        self.objUnloadDriverLog.Trace("unload_deiver End:{} {}".format(bRet,strRet))        return xRet if bRet else "--FAIL--"    @public('efidiags')    def efidiags(self, *args, **kwargs):        self._SOC_P_RESPONSE = ""        nDiagsTimeout = 4000         bRet = True        strRet = ""        strCommand=""        strDiagsDet=""        try:            nDiagsTimeout = kwargs["timeout"]-5000            #strArrPar = re.split("\*", args[0])            strCommand = args[0]            strDiagsDet=""            if len(args)>=2:                strDiagsDet=args[1]            else:                strDiagsDet = "\\>"            self.m_objEFIDiagsLog.Trace("EFIDiags Start: {} {} {}".format(nDiagsTimeout,strCommand,strDiagsDet))            self.objSocketDev.DutSetDetectString(strDiagsDet)            self._last_diags_command = strCommand            self.objSocketDev.DutReadString_str()            if self.m_objBRe.MatchStr_b(strCommand, "reset"):                self.m_objEFIDiagsLog.Trace("EFIDiags RESET Send Str:{}".format(strCommand))                self.objSocketDev.DutSendString_n(strCommand)                strRetMsg=self.objSocketDev.DutReadString_str()                self.m_objEFIDiagsLog.Trace("EFIDiags RESET Return:{}".format(strRetMsg))            elif self.m_objBRe.MatchStr_b(strCommand, "map"):                nDiagsTimeout -= 4000                nDiagsTimeout /= 4                for i in range(0,4):                    self.m_objEFIDiagsLog.Trace("{}EFIDiags MAP Send:{}".format(i,strCommand))                    nRet, strRet = self.objSocketDev.DutSendCmd_n_str(strCommand, nDiagsTimeout)                    self._last_diags_response = self.objSocketDev.DutReadString_str()                    self.m_objEFIDiagsLog.Trace("{}EFIDiags MAP Recv:{} strRet:{}".format(i,self._last_diags_response,strRet))                    if nRet != 0:                        bRet = False                        strRet = "--FAIL--EFI Communication timeout 1"                        self.m_objEFIDiagsLog.Trace("{}EFIDiags ELSE End Info :{}".format(i,strRet))                    if bRet:                        bRet, strRet = self.m_objBRe.SubStr_b_str(self._last_diags_response, "\x1b\[[0-9;]*[a-zA-Z]",                                                                  "")                        self._last_diags_response = strRet                        strRet = self._last_diags_response                        self.m_objEFIDiagsLog.Trace("{}EFIDiags MAP AfterSub Info :{}".format(i,strRet))                        if "XA" in strRet and "XB" in strRet:                            self.m_objEFIDiagsLog.Trace("{}EFIDiags MAP FIND XA XB Info :{}".format(i,strRet))                            bRet = True                            break                    self.m_objBTime.Delay(1000)            elif self.m_objBRe.MatchStr_b(strCommand, "ENTER"):                bCleanFlag = False                nBeginTimestamp = self.m_objBTime.Current()                nEndTimestamp = 0                self.m_objEFIDiagsLog.Trace("EFIDiags ENTER Loop Start")                while nEndTimestamp - nBeginTimestamp < nDiagsTimeout-5000:                    self.m_objBTime.Delay(100)                    self.m_objEFIDiagsLog.Trace("EFIDiags ENTER Send CMD:{}".format(strCommand))                    nRet, strRet = self.objSocketDev.DutSendCmd_n_str("\r\n", 4500)                    if nRet == 0:                        nEndTimestamp = self.m_objBTime.Current()                        if nDiagsTimeout - (nEndTimestamp - nBeginTimestamp) > 4500:                            self.m_objEFIDiagsLog.Trace("EFIDiags ENTER Send CMD:clear")                            self.objSocketDev.DutSendCmd_n_str("clear", 4500)                        bCleanFlag = True                        break                    self.objSocketDev.DutReadString_str()                    nEndTimestamp = self.m_objBTime.Current()                self.m_objEFIDiagsLog.Trace("EFIDiags ENTER Loop End")                if bCleanFlag != True:                    bRet = False                    strRet = "--FAIL--EFI Communication timeout"                    self.m_objEFIDiagsLog.Trace("EFIDiags ENTER Loop End Info :{}".format(strRet))            else:                nDiagsTimeout -= len(strCommand)*50                self.m_objEFIDiagsLog.Trace("EFIDiags ELSE Send:{}".format(strCommand))                nRet, strRet = self.objSocketDev.DutSendCmd_n_str(strCommand, nDiagsTimeout)                self._last_diags_response = self.objSocketDev.DutReadString_str()                self.m_objEFIDiagsLog.Trace("EFIDiags ELSE Recv:{} strRet:{}".format(self._last_diags_response,strRet))                if nRet != 0:                    bRet = False                    strRet = "--FAIL--EFI Communication timeout 1"                    self.m_objEFIDiagsLog.Trace("EFIDiags ELSE End Info :{}".format(strRet))                if bRet:                    bRet, strRet = self.m_objBRe.SubStr_b_str(self._last_diags_response, "\x1b\[[0-9;]*[a-zA-Z]", "")                    self._last_diags_response = strRet                    strRet = self._last_diags_response                    self.m_objEFIDiagsLog.Trace("EFIDiags ELSE AfterSub Info :{}".format(strRet))        except Exception as e:            bRet = False            strRet = "EXCEPT"        self.m_objEFIDiagsLog.Trace("EFIDiags End {}".format(bRet))        return "--PASS--" if bRet else "--FAIL--"    @public('efidetect')    def efidetect(self, *args, **kwargs):        bRet= True        strRet = ""        strDetect =""        try:            strDetect = args[0]            nTimeout = int(kwargs["timeout"]-3000)            self.objSocketDev.DutSetDetectString(strDetect)            nRet= self.objSocketDev.DutWaitForString_n(nTimeout)            if nRet ==0:                strRet = self.objSocketDev.DutReadString_str()                if strDetect in strRet:                    self.objSocketDev.DutReadString_str()                else:                    bRet =False            else:                strRet = "--FAIL--EFI can't detect : {}".format(strRet)                bRet =False        except:            bRet = False            strRet = "Except"        return "--PASS--" if bRet else "--FAIL--"    @public('enterefi')    def enterefi(self, *args, **kwargs):        bRet= True        strRet = ""        strCmd =""        nLoopTimeout = 0        bReset=False        try:            nLoopTimeout = int(kwargs["timeout"])-3000            strDetect=""            print "First time--"            self.m_objEfiLog.Trace("#######Start Enter Efi")            nBeginTimestamp = self.m_objBTime.Current()            nEndTimestamp = 0            bEnterAfterEsc=False            strReadback=""            while nEndTimestamp-nBeginTimestamp < nLoopTimeout:                self.m_objBTime.Delay(25)                strReadback= self.objSocketDev.DutReadString_str()                self.m_objEfiLog.Trace("#######ReadBack:{}\n#######CheckStr:{}\n".format(strReadback,strDetect))                if len(strReadback)<50:                    strDetect = strDetect+strReadback                else:                    strDetect = strReadback[-50:]                if   ":\\>" in strDetect:                    bRet=True                    self.m_objEfiLog.Trace("#######CheckIn:\\>\n")                    break                if strReadback=="":                    self.m_objEfiLog.Trace("Read None")                    bRet= False                    if nEndTimestamp-nBeginTimestamp > 10000 and bReset==False:                        self.m_objEfiLog.Trace("ReConnect Start {} {}".format(self.objSocketDev.bConnectFlag,self.objSocketDev.nConnectRet))                        if not self.objSocketDev.bConnectFlag:                            self.objSocketDev.Connect_b()                        self.m_objBTime.Delay(100)                        nEndTimestamp = self.m_objBTime.Current()                        self.objZynq.relay("PCH_UART_CTRL", "PCH_DEBUG_ZYNQ",timeout=5000)                        self.objZynq.cmd_auto_format("uart config(PCH,1250000,8,1,none,ON)")                        self.m_objBTime.Delay(1000)                        self.m_objEfiLog.Trace("ReConnect {}  Send {}".format(self.objSocketDev.bConnectFlag,"\\r\\n"))                        #self.objSocketDev.DutSendString_n("\r\n")                        if self.objSocketDev.bConnectFlag:                            bReset=True                elif "startup" in strDetect:                    self.objSocketDev.DutSendString_n(chr(27))                    self.m_objEfiLog.Trace("#######Send ESC AFter StartUp\n")                    self.m_objBTime.Delay(500)                    bEnterAfterEsc=True                elif "Exception" in strDetect and "occurred" in  strDetect:                    self.m_objEfiLog.Trace("#######Find Exception End Fail\n")                    strRet = "--FAIL--Exception occurred!!!"                    bRet = False                    break                bRet = False                nEndTimestamp = self.m_objBTime.Current()            if bRet !=True:                if self.m_objBRe.MatchStr_b(strDetect,"ROM.-Version"):                    strRet = "--FAIL--Enter MacEFI Timeout."                else:                    strRet = "--FAIL--Boot MacEFI Response Empty."                self.m_objEfiLog.Trace("#######Finish Enter Loop {}".format(strRet))        except Exception as e:            bRet = False            strRet = "Except {}".format(e)        self.m_objEfiLog.Trace("#######Finish Enter Efi {}".format(bRet))        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    @public('efisend')    def efisend(self, *args, **kwargs):        bRet= True        strRet = ""        strCmd =""        try:            strCmd = args[0]            nTimeout = int(kwargs["timeout"])            if self.m_objBRe.MatchStr_b(strCmd,"reset"):                self.objNanohippo.DutReadString_str()                self.bEnterdiagsFlag = False            if strCmd !="":                nRet = self.objSocketDev.DutSendString_n(strCmd)                if nRet==0:                    bRet=True                else:                    bRet = False            else:                bRet = False                strRet = "ERROCODE[-6]Problem with diags command string or variable substitution: ".format(strCmd)        except:            bRet = False            strRet = "Except"        return "--PASS--" if bRet else "--FAIL--"    @public('efiparse')    def efiparse(self, *args, **kwargs):        bRet= True        strRet = ""        strKeyName=""        try:            strKeyName = args[0]            bRet ,listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response, "Exception(.+?)occurred")            if bRet:                bRet = False                strRet = "DUT EFI PANIC. Panic code: {}".format(listRet[0])            else:                bRet=True            if bRet:                bRet, listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,strKeyName)                if bRet:                    strRet = listRet[0]        except Exception as e:            bRet = False            strRet = "Except {}".format(e)        print "Efi Parse :{} by:{} to:{}".format(self._last_diags_response, strKeyName, strRet)        return strRet if bRet else "--FAIL-- {}".format(strRet)    #batteryemulator    @public('diag_send')    def diag_send(self,cmd,detectStr=":-)",timeout = 20000):        bRet =True        strRet = ""        try:            self.objNanohippo.DutSetDetectString(detectStr)            self.objNanohippo.DutReadString_str()            nRet,strRet = self.objNanohippo.DutSendCmd_n_str(cmd,(timeout-8000)/2)            self._last_diags_response = self.objNanohippo.DutReadString_str()            bRet,strCmd =  self.m_objBRe.SubStrSpeci_b_str(cmd)            if nRet==0 and bRet and self.m_objBRe.MatchStr_b(self._last_diags_response,strCmd):                nRet = 0            else:                nRet = -1            if nRet != 0:                #self.g_lock.Lock(True)                self.objNanohippo.PotassiumReset_b()                self.m_objBTime.Delay(1000)                #self.g_lock.Lock(False)                nRet , strRet =self.objNanohippo.DutWaitForString_n_str(timeout)                self._last_diags_response = self.objNanohippo.DutReadString_str()                if nRet!=0 and self.m_objBRe.MatchStr_b(self._last_diags_response,strCmd):                    bRet =False                    nRet, strRet = self.objNanohippo.DutSendCmd_n_str(strCmd,(timeout-8000)/2)                    self._last_diags_response = self.objNanohippo.DutReadString_str()                    bRet, strCmd = self.m_objBRe.SubStrSpeci_b_str(cmd)                    if nRet == 0 and bRet and self.m_objBRe.MatchStr_b(self._last_diags_response, strCmd):                        bRet=True                    else:                        bRet = False                        strRet = "--FAIL--diags timeout NO_RETURN"        except:            bRet = False        return "--PASS--" if bRet else "--FAIL--"    @public('get_batt_resolution')    def get_batt_resolution(self, *args, **kwargs):        setvalue_str = "i2c -w 11 0x0D 0x31 0xFF 0xFF multiple"        self.diag_send(setvalue_str,":-)",20000)        self.m_objBTime.Delay(2000)        self.Batt_Max = float(self.read_voltage()+self.read_voltage()+self.read_voltage())/3        setvalue_str = "i2c -w 11 0x0D 0x31 0x00 0x00 multiple"        self.diag_send(setvalue_str,":-)",20000)        self.m_objBTime.Delay(2000)        self.Batt_Min = float(self.read_voltage()+self.read_voltage()+self.read_voltage())/3        Diff_Max_Min = abs(self.Batt_Max-self.Batt_Min)        strRet = "Vmin:{} Vmax:{} Colw:{}".format(self.Batt_Min,self.Batt_Max,Diff_Max_Min)    @public('init_emulator')    def init_emulator(self, *args, **kwargs):        setvalue_str = "i2c -w 11 0x22 0x00 0x08 multiple"        self.diag_send(setvalue_str,":-)",20000)        setvalue_str = "i2c -w 11 0x22 0x09 0x80 multiple"        return self.diag_send(setvalue_str,":-)",20000)        #setvalue_str = "i2c -w 11 0x0D 0x31 0xBA 0xA2 multiple"        #self.diag_send(setvalue_str,":-)",20000)    @public('disable_sink_mode')    def disable_sink_mode(self, *args, **kwargs):        close_emulator_sink_mode = "i2c -w 11 0x22 0x09 0x90 multiple"        return self.diag_send(close_emulator_sink_mode,":-)",20000)    @public('read_voltage')    def read_voltage(self, *args, **kwargs):        bRet = True        strRet =""        try:            strRet = self.diag_send("i2c -w 11 0x4A 0x4C",":-)",20000)            self.m_objBTime.Delay(20)            strRet = self.diag_send("i2c -r 11 0x4A 0x03", ":-)",20000)            if self.m_objBRe.MatchStr_b(self._last_diags_response,"buffer read:\s*(.*)\s*0x4C"):                bRet,strRet = self.m_objBRe.SubStr_b_str(strRet,"0x| ","")                    nRet = int(strRet,16)                strRet = str(7.8*2.048*nRet/32768)        except Exception as e:            strRet = "Exception read_voltage"                return strRet    @public('read_sink_current')    def read_sink_current(self, *args, **kwargs):        bRet = True        strRet =""        nRet = -1        try:            strRet = self.diag_send("i2c -w 11 0x4A 0x6C",":-)")            self.m_objBTime.Delay(20)            strRet=self.diag_send("i2c -r 11 0x4A 0x03",":-)")            bRet,listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,"buffer read:\s*(.*)\s*0x6C")            if bRet:                bRet,strRet = self.m_objBRe.SubStr_b_str(listRet[0],"0x| ","")                    nRet = int(strRet,16)                if nRet > 16383:                    nRet = nRet - 1- 65535                nRet = 2.048*nRet/32768/0.25                if "MA" == kwargs["unit"].upper():                    nRet=nRet*1000                elif "UA" ==kwargs["unit"].upper():                    nRet = nRet*1000*1000                                #if self.m_objBRe.MatchOrInList_b(["MA","A","UA"],kwargs["unit"].upper()):                #   #mA To A ?                #   pass                strRet=str(nRet)            else:                bRet = False        except Exception as e:            bRet = False            strRet = "Exception read_voltage"                return nRet if bRet else "--FAIL--"    @public('read_source_current')    def read_source_current(self, *args, **kwargs):        bRet = True        strRet =""        nRet=-1        try:            strRet = self.diag_send("i2c -w 11 0x4A 0x2C",":-)")            self.m_objBTime.Delay(20)            strRet = self.diag_send("i2c -r 11 0x4A 0x03",":-)")            bRet,listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,"buffer read:\s*(.*)\s*0x2C")            if bRet:                bRet,strRet = self.m_objBRe.SubStr_b_str(listRet[0],"0x| ","")                    nRet = int(strRet,16)                if nRet > 16383:                    nRet = nRet - 1- 65535                nRet = 2.048*nRet/32768/0.25                if "MA" == kwargs["unit"].upper():                    nRet = nRet * 1000                elif "UA" == kwargs["unit"].upper():                    nRet = nRet * 1000 * 1000            else:                bRet = False        except Exception as e:            bRet = False            strRet = "Exception read_voltage"                return nRet if bRet else "--FAIL--"    @public('read_voltage_setting')    def read_voltage_setting(self, *args, **kwargs):        bRet = True        nRet= 0        try:            self.diag_send("i2c -w 11 0x0D 0x01")            self.m_objBTime.Delay(20)            self.diag_send("i2c -r 11 0x0D 0x02",":-)")            nRet = 0            print "read_voltage_setting _last_diags_response :{}".format(self._last_diags_response)            bRet,listRet = self.m_objBRe.MatchStr_b_list(self._last_diags_response,"buffer read:\s*(.*)\s*\[")            if bRet:                bRet,strRet = self.m_objBRe.SubStr_b_str(listRet[0],"0x| ","")                nRet = int(strRet,16)                nRet = self.Batt_Max - float(self.Batt_Max - self.Batt_Min) / 65535.0 * nRet        except:            bRet = False        return nRet if bRet else 0    @public('set_voltage')    def set_voltage(self,fvolts):        bRet = True        try:            if fvolts > self.Batt_Max:                fvolts = self.Batt_Max            elif fvolts < self.Batt_Min:                fvolts = self.Batt_Min            nTemp = float((self.Batt_Max - fvolts)) * 65535.0 / float(self.Batt_Max-self.Batt_Min)            fTemp = nTemp + 0.5            strSetValue ="0x%04x"%fTemp            strSetValueH=strSetValue[:-2]            strSetValueL = strSetValue[-2:]            self.diag_send("i2c -w 11 0x0D 0x31 {} 0x{} multiple".format(strSetValueH,strSetValueL),":-)",20000)        except:            bRet = False        return "--PASS--" if bRet else "--FAIL--"    @public('trim_battery_output')    def trim_battery_output(self, *args, **kwargs):        bRet = True        strRet =""        try:            Vtarget = float(args[0])*1000            tolerance = float(args[1])*1000            starttime = self.m_objBTime.Current()            currenttime = 0            self.m_objTrimLog.Trace("Trim Start : {} {}".format(Vtarget,tolerance))            vbat = self.objZynq.dmm("PPVBAT_G3H_CONN_DIV",unit="mV")            nextV = self.read_voltage_setting()            timeout = kwargs["timeout"]-2000            self.m_objTrimLog.Trace("Trim Start : Target {} TimeOut {} Next {}".format(Vtarget,timeout,nextV))            while ((currenttime - starttime) < timeout):                if vbat > 13100 or vbat < 7000:                    vbat = self.objZynq.dmm("PPVBAT_G3H_CONN_DIV",unit="mV")                elif Vtarget > 9000 and vbat < 9000:                    nextV = (9100 - vbat) + nextV                elif Vtarget < 9000 and vbat > 9000:                    nextV = (8900 - vbat) + nextV                else:                    nextV = (Vtarget - vbat) + nextV                self.m_objTrimLog.Trace("Trim Loop Set Voltage {}".format(nextV))                self.set_voltage(nextV)                self.m_objBTime.Delay(500)                vbat = self.objZynq.dmm("PPVBAT_G3H_CONN_DIV",unit="mV",timeout=timeout)                self.m_objTrimLog.Trace("Trim Loop Check: Current: {} Target {} Tolerance {}".format(vbat,Vtarget, timeout))                if abs(Vtarget-vbat) <= tolerance:                    self.m_objTrimLog.Trace("Trim Loop Check OK")                    bRet=True                    break                strRet=str(vbat)                currenttime = self.m_objBTime.Current()                bRet = False        except Exception as e:            bRet = False            strRet = "Exception trim_battery_output"        self.m_objTrimLog.Trace("Trim End Result: {}".format(bRet))        return "--PASS--" if bRet else "--FAIL--{}".format(strRet)    @public('check_nand_zero')    def check_nand_zero(self, *args, **kwargs):        bRet = True        strRet = ""        try:            strRet = self.parse(args[0])            #self.m_objRecoverLog.Trace("check_nand_zero return parse str :{}".format(strRet))            bRet,strRet = self.m_objBRe.SubStr_b_str(strRet," ","")            self.strNandZero = strRet[0:40]            #self.m_objRecoverLog.Trace("check_nand_zero return str :{}".format(strRet))            for i in strRet:                if int(i) != 0:                    bRet = False                    strRet = "{}".format(i)                    break        except Exception as e:            bRet = False            strRet = "Exception {}".format(e)        return "--PASS--" if bRet else "--FAIL-- {}".format(strRet)    @public('parse_str')    def parse_str(self, *args, **kwargs):        bRet = True        strRet = ""        try:            self.m_objNandLog.Trace("Start Parse_str {} {} Start".format(self.strNandZero,args[1]))            nIndex = int(args[1])            strRet = self.strNandZero[nIndex*8:nIndex*8+8]        except Exception as e:            bRet = False            strRet = "Exception {}".format(e)        self.m_objNandLog.Trace("Start Parse_str {} End".format(strRet))        return strRet if bRet else "--FAIL-- {}".format(strRet)